// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WEBRTC_WEBSTREAMER_WEBRTC_TOPICS_H_
#define FLATBUFFERS_GENERATED_WEBRTC_WEBSTREAMER_WEBRTC_TOPICS_H_

#include "flatbuffers/flatbuffers.h"

namespace webstreamer {
namespace webrtc {
namespace topics {

struct Endpoint;

struct SubscribeItem;

struct Topic;

struct TopicSubscribe;

struct TopicNotification;

struct TopicPush;

struct TopicAny;

}  // namespace topics

enum SdpRole {
  SdpRole_OFFER = 0,
  SdpRole_ANSWER = 1,
  SdpRole_ANY = 2,
  SdpRole_MIN = SdpRole_OFFER,
  SdpRole_MAX = SdpRole_ANY
};

inline SdpRole (&EnumValuesSdpRole())[3] {
  static SdpRole values[] = {
    SdpRole_OFFER,
    SdpRole_ANSWER,
    SdpRole_ANY
  };
  return values;
}

inline const char **EnumNamesSdpRole() {
  static const char *names[] = {
    "OFFER",
    "ANSWER",
    "ANY",
    nullptr
  };
  return names;
}

inline const char *EnumNameSdpRole(SdpRole e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSdpRole()[index];
}

enum StreamMode {
  StreamMode_SENDONLY = 0,
  StreamMode_RECVONLY = 1,
  StreamMode_SENDRECV = 2,
  StreamMode_MIN = StreamMode_SENDONLY,
  StreamMode_MAX = StreamMode_SENDRECV
};

inline StreamMode (&EnumValuesStreamMode())[3] {
  static StreamMode values[] = {
    StreamMode_SENDONLY,
    StreamMode_RECVONLY,
    StreamMode_SENDRECV
  };
  return values;
}

inline const char **EnumNamesStreamMode() {
  static const char *names[] = {
    "SENDONLY",
    "RECVONLY",
    "SENDRECV",
    nullptr
  };
  return names;
}

inline const char *EnumNameStreamMode(StreamMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStreamMode()[index];
}

namespace topics {

enum TopicCategory {
  TopicCategory_SDP = 0,
  TopicCategory_STATUS = 1,
  TopicCategory_MIN = TopicCategory_SDP,
  TopicCategory_MAX = TopicCategory_STATUS
};

inline TopicCategory (&EnumValuesTopicCategory())[2] {
  static TopicCategory values[] = {
    TopicCategory_SDP,
    TopicCategory_STATUS
  };
  return values;
}

inline const char **EnumNamesTopicCategory() {
  static const char *names[] = {
    "SDP",
    "STATUS",
    nullptr
  };
  return names;
}

inline const char *EnumNameTopicCategory(TopicCategory e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTopicCategory()[index];
}

enum Any {
  Any_NONE = 0,
  Any_TopicSubscribe = 1,
  Any_TopicNotification = 2,
  Any_TopicPush = 3,
  Any_MIN = Any_NONE,
  Any_MAX = Any_TopicPush
};

inline Any (&EnumValuesAny())[4] {
  static Any values[] = {
    Any_NONE,
    Any_TopicSubscribe,
    Any_TopicNotification,
    Any_TopicPush
  };
  return values;
}

inline const char **EnumNamesAny() {
  static const char *names[] = {
    "NONE",
    "TopicSubscribe",
    "TopicNotification",
    "TopicPush",
    nullptr
  };
  return names;
}

inline const char *EnumNameAny(Any e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAny()[index];
}

template<typename T> struct AnyTraits {
  static const Any enum_value = Any_NONE;
};

template<> struct AnyTraits<TopicSubscribe> {
  static const Any enum_value = Any_TopicSubscribe;
};

template<> struct AnyTraits<TopicNotification> {
  static const Any enum_value = Any_TopicNotification;
};

template<> struct AnyTraits<TopicPush> {
  static const Any enum_value = Any_TopicPush;
};

bool VerifyAny(flatbuffers::Verifier &verifier, const void *obj, Any type);
bool VerifyAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Endpoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SDP_ROLE = 4,
    VT_CONNECTION = 6,
    VT_GROUP = 8
  };
  webstreamer::webrtc::SdpRole sdp_role() const {
    return static_cast<webstreamer::webrtc::SdpRole>(GetField<int8_t>(VT_SDP_ROLE, 0));
  }
  const flatbuffers::String *connection() const {
    return GetPointer<const flatbuffers::String *>(VT_CONNECTION);
  }
  const flatbuffers::String *group() const {
    return GetPointer<const flatbuffers::String *>(VT_GROUP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SDP_ROLE) &&
           VerifyOffset(verifier, VT_CONNECTION) &&
           verifier.Verify(connection()) &&
           VerifyOffset(verifier, VT_GROUP) &&
           verifier.Verify(group()) &&
           verifier.EndTable();
  }
};

struct EndpointBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sdp_role(webstreamer::webrtc::SdpRole sdp_role) {
    fbb_.AddElement<int8_t>(Endpoint::VT_SDP_ROLE, static_cast<int8_t>(sdp_role), 0);
  }
  void add_connection(flatbuffers::Offset<flatbuffers::String> connection) {
    fbb_.AddOffset(Endpoint::VT_CONNECTION, connection);
  }
  void add_group(flatbuffers::Offset<flatbuffers::String> group) {
    fbb_.AddOffset(Endpoint::VT_GROUP, group);
  }
  explicit EndpointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndpointBuilder &operator=(const EndpointBuilder &);
  flatbuffers::Offset<Endpoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Endpoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Endpoint> CreateEndpoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    webstreamer::webrtc::SdpRole sdp_role = webstreamer::webrtc::SdpRole_OFFER,
    flatbuffers::Offset<flatbuffers::String> connection = 0,
    flatbuffers::Offset<flatbuffers::String> group = 0) {
  EndpointBuilder builder_(_fbb);
  builder_.add_group(group);
  builder_.add_connection(connection);
  builder_.add_sdp_role(sdp_role);
  return builder_.Finish();
}

inline flatbuffers::Offset<Endpoint> CreateEndpointDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    webstreamer::webrtc::SdpRole sdp_role = webstreamer::webrtc::SdpRole_OFFER,
    const char *connection = nullptr,
    const char *group = nullptr) {
  return webstreamer::webrtc::topics::CreateEndpoint(
      _fbb,
      sdp_role,
      connection ? _fbb.CreateString(connection) : 0,
      group ? _fbb.CreateString(group) : 0);
}

struct SubscribeItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENDPOINT = 4,
    VT_TOPICS = 6
  };
  const Endpoint *endpoint() const {
    return GetPointer<const Endpoint *>(VT_ENDPOINT);
  }
  const flatbuffers::Vector<int8_t> *topics() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_TOPICS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENDPOINT) &&
           verifier.VerifyTable(endpoint()) &&
           VerifyOffset(verifier, VT_TOPICS) &&
           verifier.Verify(topics()) &&
           verifier.EndTable();
  }
};

struct SubscribeItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_endpoint(flatbuffers::Offset<Endpoint> endpoint) {
    fbb_.AddOffset(SubscribeItem::VT_ENDPOINT, endpoint);
  }
  void add_topics(flatbuffers::Offset<flatbuffers::Vector<int8_t>> topics) {
    fbb_.AddOffset(SubscribeItem::VT_TOPICS, topics);
  }
  explicit SubscribeItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubscribeItemBuilder &operator=(const SubscribeItemBuilder &);
  flatbuffers::Offset<SubscribeItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubscribeItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubscribeItem> CreateSubscribeItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Endpoint> endpoint = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> topics = 0) {
  SubscribeItemBuilder builder_(_fbb);
  builder_.add_topics(topics);
  builder_.add_endpoint(endpoint);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubscribeItem> CreateSubscribeItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Endpoint> endpoint = 0,
    const std::vector<int8_t> *topics = nullptr) {
  return webstreamer::webrtc::topics::CreateSubscribeItem(
      _fbb,
      endpoint,
      topics ? _fbb.CreateVector<int8_t>(*topics) : 0);
}

struct Topic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CATEGORY = 4,
    VT_SDP = 6,
    VT_STATUS = 8
  };
  TopicCategory category() const {
    return static_cast<TopicCategory>(GetField<int8_t>(VT_CATEGORY, 0));
  }
  const flatbuffers::String *sdp() const {
    return GetPointer<const flatbuffers::String *>(VT_SDP);
  }
  const flatbuffers::String *status() const {
    return GetPointer<const flatbuffers::String *>(VT_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CATEGORY) &&
           VerifyOffset(verifier, VT_SDP) &&
           verifier.Verify(sdp()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.Verify(status()) &&
           verifier.EndTable();
  }
};

struct TopicBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_category(TopicCategory category) {
    fbb_.AddElement<int8_t>(Topic::VT_CATEGORY, static_cast<int8_t>(category), 0);
  }
  void add_sdp(flatbuffers::Offset<flatbuffers::String> sdp) {
    fbb_.AddOffset(Topic::VT_SDP, sdp);
  }
  void add_status(flatbuffers::Offset<flatbuffers::String> status) {
    fbb_.AddOffset(Topic::VT_STATUS, status);
  }
  explicit TopicBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopicBuilder &operator=(const TopicBuilder &);
  flatbuffers::Offset<Topic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Topic>(end);
    return o;
  }
};

inline flatbuffers::Offset<Topic> CreateTopic(
    flatbuffers::FlatBufferBuilder &_fbb,
    TopicCategory category = TopicCategory_SDP,
    flatbuffers::Offset<flatbuffers::String> sdp = 0,
    flatbuffers::Offset<flatbuffers::String> status = 0) {
  TopicBuilder builder_(_fbb);
  builder_.add_status(status);
  builder_.add_sdp(sdp);
  builder_.add_category(category);
  return builder_.Finish();
}

inline flatbuffers::Offset<Topic> CreateTopicDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    TopicCategory category = TopicCategory_SDP,
    const char *sdp = nullptr,
    const char *status = nullptr) {
  return webstreamer::webrtc::topics::CreateTopic(
      _fbb,
      category,
      sdp ? _fbb.CreateString(sdp) : 0,
      status ? _fbb.CreateString(status) : 0);
}

struct TopicSubscribe FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SubscribeItem>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SubscribeItem>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.Verify(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           verifier.EndTable();
  }
};

struct TopicSubscribeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubscribeItem>>> items) {
    fbb_.AddOffset(TopicSubscribe::VT_ITEMS, items);
  }
  explicit TopicSubscribeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopicSubscribeBuilder &operator=(const TopicSubscribeBuilder &);
  flatbuffers::Offset<TopicSubscribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicSubscribe>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicSubscribe> CreateTopicSubscribe(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubscribeItem>>> items = 0) {
  TopicSubscribeBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<TopicSubscribe> CreateTopicSubscribeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SubscribeItem>> *items = nullptr) {
  return webstreamer::webrtc::topics::CreateTopicSubscribe(
      _fbb,
      items ? _fbb.CreateVector<flatbuffers::Offset<SubscribeItem>>(*items) : 0);
}

struct TopicNotification FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENDPOINT = 4,
    VT_TOPIC = 6
  };
  const Endpoint *endpoint() const {
    return GetPointer<const Endpoint *>(VT_ENDPOINT);
  }
  const Topic *topic() const {
    return GetPointer<const Topic *>(VT_TOPIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENDPOINT) &&
           verifier.VerifyTable(endpoint()) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyTable(topic()) &&
           verifier.EndTable();
  }
};

struct TopicNotificationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_endpoint(flatbuffers::Offset<Endpoint> endpoint) {
    fbb_.AddOffset(TopicNotification::VT_ENDPOINT, endpoint);
  }
  void add_topic(flatbuffers::Offset<Topic> topic) {
    fbb_.AddOffset(TopicNotification::VT_TOPIC, topic);
  }
  explicit TopicNotificationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopicNotificationBuilder &operator=(const TopicNotificationBuilder &);
  flatbuffers::Offset<TopicNotification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicNotification>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicNotification> CreateTopicNotification(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Endpoint> endpoint = 0,
    flatbuffers::Offset<Topic> topic = 0) {
  TopicNotificationBuilder builder_(_fbb);
  builder_.add_topic(topic);
  builder_.add_endpoint(endpoint);
  return builder_.Finish();
}

struct TopicPush FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENDPOINT = 4,
    VT_TOPIC = 6
  };
  const Endpoint *endpoint() const {
    return GetPointer<const Endpoint *>(VT_ENDPOINT);
  }
  const Topic *topic() const {
    return GetPointer<const Topic *>(VT_TOPIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENDPOINT) &&
           verifier.VerifyTable(endpoint()) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyTable(topic()) &&
           verifier.EndTable();
  }
};

struct TopicPushBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_endpoint(flatbuffers::Offset<Endpoint> endpoint) {
    fbb_.AddOffset(TopicPush::VT_ENDPOINT, endpoint);
  }
  void add_topic(flatbuffers::Offset<Topic> topic) {
    fbb_.AddOffset(TopicPush::VT_TOPIC, topic);
  }
  explicit TopicPushBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopicPushBuilder &operator=(const TopicPushBuilder &);
  flatbuffers::Offset<TopicPush> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicPush>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicPush> CreateTopicPush(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Endpoint> endpoint = 0,
    flatbuffers::Offset<Topic> topic = 0) {
  TopicPushBuilder builder_(_fbb);
  builder_.add_topic(topic);
  builder_.add_endpoint(endpoint);
  return builder_.Finish();
}

struct TopicAny FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ANY_TYPE = 4,
    VT_ANY = 6
  };
  Any any_type() const {
    return static_cast<Any>(GetField<uint8_t>(VT_ANY_TYPE, 0));
  }
  const void *any() const {
    return GetPointer<const void *>(VT_ANY);
  }
  template<typename T> const T *any_as() const;
  const TopicSubscribe *any_as_TopicSubscribe() const {
    return any_type() == Any_TopicSubscribe ? static_cast<const TopicSubscribe *>(any()) : nullptr;
  }
  const TopicNotification *any_as_TopicNotification() const {
    return any_type() == Any_TopicNotification ? static_cast<const TopicNotification *>(any()) : nullptr;
  }
  const TopicPush *any_as_TopicPush() const {
    return any_type() == Any_TopicPush ? static_cast<const TopicPush *>(any()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ANY_TYPE) &&
           VerifyOffset(verifier, VT_ANY) &&
           VerifyAny(verifier, any(), any_type()) &&
           verifier.EndTable();
  }
};

template<> inline const TopicSubscribe *TopicAny::any_as<TopicSubscribe>() const {
  return any_as_TopicSubscribe();
}

template<> inline const TopicNotification *TopicAny::any_as<TopicNotification>() const {
  return any_as_TopicNotification();
}

template<> inline const TopicPush *TopicAny::any_as<TopicPush>() const {
  return any_as_TopicPush();
}

struct TopicAnyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_any_type(Any any_type) {
    fbb_.AddElement<uint8_t>(TopicAny::VT_ANY_TYPE, static_cast<uint8_t>(any_type), 0);
  }
  void add_any(flatbuffers::Offset<void> any) {
    fbb_.AddOffset(TopicAny::VT_ANY, any);
  }
  explicit TopicAnyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopicAnyBuilder &operator=(const TopicAnyBuilder &);
  flatbuffers::Offset<TopicAny> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicAny>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicAny> CreateTopicAny(
    flatbuffers::FlatBufferBuilder &_fbb,
    Any any_type = Any_NONE,
    flatbuffers::Offset<void> any = 0) {
  TopicAnyBuilder builder_(_fbb);
  builder_.add_any(any);
  builder_.add_any_type(any_type);
  return builder_.Finish();
}

inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *obj, Any type) {
  switch (type) {
    case Any_NONE: {
      return true;
    }
    case Any_TopicSubscribe: {
      auto ptr = reinterpret_cast<const TopicSubscribe *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_TopicNotification: {
      auto ptr = reinterpret_cast<const TopicNotification *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Any_TopicPush: {
      auto ptr = reinterpret_cast<const TopicPush *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAny(
        verifier,  values->Get(i), types->GetEnum<Any>(i))) {
      return false;
    }
  }
  return true;
}

inline const webstreamer::webrtc::topics::TopicAny *GetTopicAny(const void *buf) {
  return flatbuffers::GetRoot<webstreamer::webrtc::topics::TopicAny>(buf);
}

inline bool VerifyTopicAnyBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<webstreamer::webrtc::topics::TopicAny>(nullptr);
}

inline void FinishTopicAnyBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<webstreamer::webrtc::topics::TopicAny> root) {
  fbb.Finish(root);
}

}  // namespace topics
}  // namespace webrtc
}  // namespace webstreamer

#endif  // FLATBUFFERS_GENERATED_WEBRTC_WEBSTREAMER_WEBRTC_TOPICS_H_
