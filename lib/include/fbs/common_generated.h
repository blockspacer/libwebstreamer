// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMMON_WEBSTREAMER_H_
#define FLATBUFFERS_GENERATED_COMMON_WEBSTREAMER_H_

#include "flatbuffers/flatbuffers.h"

namespace webstreamer {

struct Channel;

struct Endpoint;

struct Topic;

struct Subscription;

struct Channel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CODEC = 4,
    VT_MODE = 6
  };
  const flatbuffers::String *codec() const {
    return GetPointer<const flatbuffers::String *>(VT_CODEC);
  }
  const flatbuffers::String *mode() const {
    return GetPointer<const flatbuffers::String *>(VT_MODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODEC) &&
           verifier.Verify(codec()) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.Verify(mode()) &&
           verifier.EndTable();
  }
};

struct ChannelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_codec(flatbuffers::Offset<flatbuffers::String> codec) {
    fbb_.AddOffset(Channel::VT_CODEC, codec);
  }
  void add_mode(flatbuffers::Offset<flatbuffers::String> mode) {
    fbb_.AddOffset(Channel::VT_MODE, mode);
  }
  explicit ChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChannelBuilder &operator=(const ChannelBuilder &);
  flatbuffers::Offset<Channel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Channel>(end);
    return o;
  }
};

inline flatbuffers::Offset<Channel> CreateChannel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> codec = 0,
    flatbuffers::Offset<flatbuffers::String> mode = 0) {
  ChannelBuilder builder_(_fbb);
  builder_.add_mode(mode);
  builder_.add_codec(codec);
  return builder_.Finish();
}

inline flatbuffers::Offset<Channel> CreateChannelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *codec = nullptr,
    const char *mode = nullptr) {
  return webstreamer::CreateChannel(
      _fbb,
      codec ? _fbb.CreateString(codec) : 0,
      mode ? _fbb.CreateString(mode) : 0);
}

struct Endpoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_URL = 6,
    VT_INITIATIVE = 8,
    VT_CHANNEL = 10
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *url() const {
    return GetPointer<const flatbuffers::String *>(VT_URL);
  }
  bool initiative() const {
    return GetField<uint8_t>(VT_INITIATIVE, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Channel>> *channel() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Channel>> *>(VT_CHANNEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.Verify(id()) &&
           VerifyOffset(verifier, VT_URL) &&
           verifier.Verify(url()) &&
           VerifyField<uint8_t>(verifier, VT_INITIATIVE) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           verifier.VerifyVectorOfTables(channel()) &&
           verifier.EndTable();
  }
};

struct EndpointBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Endpoint::VT_ID, id);
  }
  void add_url(flatbuffers::Offset<flatbuffers::String> url) {
    fbb_.AddOffset(Endpoint::VT_URL, url);
  }
  void add_initiative(bool initiative) {
    fbb_.AddElement<uint8_t>(Endpoint::VT_INITIATIVE, static_cast<uint8_t>(initiative), 0);
  }
  void add_channel(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Channel>>> channel) {
    fbb_.AddOffset(Endpoint::VT_CHANNEL, channel);
  }
  explicit EndpointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndpointBuilder &operator=(const EndpointBuilder &);
  flatbuffers::Offset<Endpoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Endpoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Endpoint> CreateEndpoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> url = 0,
    bool initiative = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Channel>>> channel = 0) {
  EndpointBuilder builder_(_fbb);
  builder_.add_channel(channel);
  builder_.add_url(url);
  builder_.add_id(id);
  builder_.add_initiative(initiative);
  return builder_.Finish();
}

inline flatbuffers::Offset<Endpoint> CreateEndpointDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *url = nullptr,
    bool initiative = false,
    const std::vector<flatbuffers::Offset<Channel>> *channel = nullptr) {
  return webstreamer::CreateEndpoint(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      url ? _fbb.CreateString(url) : 0,
      initiative,
      channel ? _fbb.CreateVector<flatbuffers::Offset<Channel>>(*channel) : 0);
}

struct Topic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_COMPONENT = 6,
    VT_ENDPOINT = 8,
    VT_CONTENT = 10
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *component() const {
    return GetPointer<const flatbuffers::String *>(VT_COMPONENT);
  }
  const flatbuffers::String *endpoint() const {
    return GetPointer<const flatbuffers::String *>(VT_ENDPOINT);
  }
  const flatbuffers::String *content() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.Verify(type()) &&
           VerifyOffset(verifier, VT_COMPONENT) &&
           verifier.Verify(component()) &&
           VerifyOffset(verifier, VT_ENDPOINT) &&
           verifier.Verify(endpoint()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.Verify(content()) &&
           verifier.EndTable();
  }
};

struct TopicBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Topic::VT_TYPE, type);
  }
  void add_component(flatbuffers::Offset<flatbuffers::String> component) {
    fbb_.AddOffset(Topic::VT_COMPONENT, component);
  }
  void add_endpoint(flatbuffers::Offset<flatbuffers::String> endpoint) {
    fbb_.AddOffset(Topic::VT_ENDPOINT, endpoint);
  }
  void add_content(flatbuffers::Offset<flatbuffers::String> content) {
    fbb_.AddOffset(Topic::VT_CONTENT, content);
  }
  explicit TopicBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopicBuilder &operator=(const TopicBuilder &);
  flatbuffers::Offset<Topic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Topic>(end);
    return o;
  }
};

inline flatbuffers::Offset<Topic> CreateTopic(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> component = 0,
    flatbuffers::Offset<flatbuffers::String> endpoint = 0,
    flatbuffers::Offset<flatbuffers::String> content = 0) {
  TopicBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_endpoint(endpoint);
  builder_.add_component(component);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Topic> CreateTopicDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *component = nullptr,
    const char *endpoint = nullptr,
    const char *content = nullptr) {
  return webstreamer::CreateTopic(
      _fbb,
      type ? _fbb.CreateString(type) : 0,
      component ? _fbb.CreateString(component) : 0,
      endpoint ? _fbb.CreateString(endpoint) : 0,
      content ? _fbb.CreateString(content) : 0);
}

struct Subscription FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_COMPONENT = 6,
    VT_ENDPOINT = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *type() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TYPE);
  }
  const flatbuffers::String *component() const {
    return GetPointer<const flatbuffers::String *>(VT_COMPONENT);
  }
  const flatbuffers::String *endpoint() const {
    return GetPointer<const flatbuffers::String *>(VT_ENDPOINT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.Verify(type()) &&
           verifier.VerifyVectorOfStrings(type()) &&
           VerifyOffset(verifier, VT_COMPONENT) &&
           verifier.Verify(component()) &&
           VerifyOffset(verifier, VT_ENDPOINT) &&
           verifier.Verify(endpoint()) &&
           verifier.EndTable();
  }
};

struct SubscriptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> type) {
    fbb_.AddOffset(Subscription::VT_TYPE, type);
  }
  void add_component(flatbuffers::Offset<flatbuffers::String> component) {
    fbb_.AddOffset(Subscription::VT_COMPONENT, component);
  }
  void add_endpoint(flatbuffers::Offset<flatbuffers::String> endpoint) {
    fbb_.AddOffset(Subscription::VT_ENDPOINT, endpoint);
  }
  explicit SubscriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubscriptionBuilder &operator=(const SubscriptionBuilder &);
  flatbuffers::Offset<Subscription> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Subscription>(end);
    return o;
  }
};

inline flatbuffers::Offset<Subscription> CreateSubscription(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> type = 0,
    flatbuffers::Offset<flatbuffers::String> component = 0,
    flatbuffers::Offset<flatbuffers::String> endpoint = 0) {
  SubscriptionBuilder builder_(_fbb);
  builder_.add_endpoint(endpoint);
  builder_.add_component(component);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Subscription> CreateSubscriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *type = nullptr,
    const char *component = nullptr,
    const char *endpoint = nullptr) {
  return webstreamer::CreateSubscription(
      _fbb,
      type ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*type) : 0,
      component ? _fbb.CreateString(component) : 0,
      endpoint ? _fbb.CreateString(endpoint) : 0);
}

}  // namespace webstreamer

#endif  // FLATBUFFERS_GENERATED_COMMON_WEBSTREAMER_H_
